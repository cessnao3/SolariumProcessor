# Registers
R0-15
R0 = PC
R1 = SP
R2 = STATUS
R3 = ZERO
R4-15 = General Purpose Registers

# Basic Instruction Syntax

0x000F | 0x00F0 | 0x0F00 | 0xF000
opcode |  arg0  |  arg1  |  arg2

# Jump Instructions

Instruction Format
    arg0 =
        0x1 -> Arg 2 is relative
    arg1 = Register 1 (0xF), Register 2 (0xF0)
    arg2 = Relative Address (+/- 128) or Absolute (Register 3)

JMP = 0x20
JNE/JNZ = 0x21
JEQ/JEZ = 0x22
JN = 0x23
JP = 0x24
JGE = 0x25
JG = 0x26
JLE = 0x27
JL = 0x28

# Copy

Instruction Format
    arg0 =
        0x1 -> source is register (otherwise, uses address in register)
        0x2 -> destination is register (otherwise, uses address in register)
    arg1 = Register 1 (Source, 0x0F) and Register 2 (Destination, 0x0F0)
    arg2 = ??

COPY = 0x30

# Arithmetic

Instruction Format
    arg0 =
        0x1 -> register 3 is address
        0x2 -> Operand A is immediate (-128 to 127)
        0x4 -> Operand B is immediate (-128 to 127)
        0xF0 -> register 3 (Destination)
    arg1 = Register 1 (Operand A)
    arg2 = Register 2 (Operand B)

ADD = 0x40
SUB = 0x41
MUL = 0x42
DIV = 0x43
MOD = 0x44

# Bit Operations
BAND
BOR

BSHIFT

# Extra Instructions
PUSH
CALL
RET
POP
NOOP = 0x00
HALT = 0x01
INTERRUPT

# Memory

2^16 16-bit values

# Interrupt
Special interrupt vector that will push onto stack, then pop back on RET
16 different interrupt vectors, along with init vector, at end of array

# Devices
Memory-Mapped
Device-timed memory to prevent impartial read/writes
