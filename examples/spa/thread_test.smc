.loadloc program_start
.loadloc program_start

.oper 0x20
.loadloc hw_int_0

.oper 0x100
:global_num_threads
.load 0
:global_current_thread
.load 0
:global_thread_pc_stack

.oper 0x400
:stack_pointer_base

.oper 0x600
:thread_1_sp_base

.oper 0x800
:thread_2_sp_base

.oper 0x3000

:init_thread

; Load useful parameters to registers
ldi 7, 1
ldi 10, 0
ldi 11, 16

; Load the main start location into register 8
ld 8, $arg

; Increment and load the stack location into register 9
add $arg, $arg, 7
ld 9, $arg

; Copy the base SP into a register with the ending location
add 11, 9, 11

; Save the stack location to the global PC stack
ldn 13
.loadloc global_num_threads
ld 14, 13

ldn 12
.loadloc global_thread_pc_stack
add 12, 12, 14
sav 12, 11

add 14, 14, 7
sav 13, 14

; Push PC (R0) to the new stack
sav 9, 8
add 9, 9, 7

; Push Flags (R1) to the new stack
sav 9, $stat
add 9, 9, 7

; Push SP (R2) to the new stack
sav 9, 11
add 9, 9, 7

; Push SPB (R3) to the new stack
add 9, 9, 7

; Push return and argument registers (R4, R5)
sav 9, 10
add 9, 9, 7
sav 9, 10

ret

:hw_int_0

; Load constants
ldn 9
.loadloc global_current_thread
ld 10, 9
ldn 11
.loadloc global_num_threads
ld 11, 11
ldn 12
.loadloc global_thread_pc_stack

; Save the current stack
add 13, 12, 10
sav 13, $sp

; Increment to the next stack
ldi 14, 1
add 10, 10, 14
rem 10, 10, 11
add 13, 12, 10
ld $sp, 13
sav 9, 10

; Resume the next thread
retint

.oper 0x4000
:program_start

ldn $sp
.loadloc stack_pointer_base

; Start to init thread 1
ldn 10
.loadloc thread_1_main
ldn 11
.loadloc thread_1_sp_base
ldn 12
.loadloc init_thread

copy $arg, $sp
push 10
push 11
call 12
pop
pop

ldn 10
.loadloc thread_2_main
ldn 11
.loadloc thread_2_sp_base

push 10
push 11
call 12
pop
pop

ldn $sp
.loadloc global_thread_pc_stack
ld $sp, $sp
halt
retint

:temp_loc
noop
noop
noop
jmpri temp_loc

.oper 0x6000
:thread_1_main
inton
:thread_1_loop
noop
noop
noop
jmpri thread_1_loop

.oper 0x8000
:thread_2_main
inton
:thread_2_loop
noop
noop
jmpri thread_2_loop
